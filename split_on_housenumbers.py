from llama_index.core import PromptTemplate
import os
import pandas as pd
from tqdm import tqdm
from openai import Client,OpenAI
import json
import re
import logging


def System_Message(jsonschema):
    system_template = """
    You are an archive expert and your task is to extract required information from the OCR'ed text. Note that OCR'ed text might contain some errors.
	The text follows a fixed format:

    Name:
        The surname comes first, followed by initials (e.g., 'Jansen (A.B.)').
        Example: 'De Vries (J.)', 'Van Dijk (A.B.)'.

    Job Title (if available):
        Appears after the name, often separated by a comma.
        May be written in full or abbreviated (e.g., 'Dokter', 'Dr.', 'Ingenieur', 'Ir.', 'Werkman', 'Boekbindkn.', 'Metselaar', 'Agent').

    Address:
        Appears at the end of the sentence.
        Includes a street name and, if available, a house number (e.g., 'Hoofdstraat 12', 'Bakkerstraat', Zuiderdiep 46b).
		May be written in full or abbreviated (e.g., 'Verl. Hereweg', 'O. Ebbingestr.', 'Zuiderdiep', 'Gebr. Bakkerstraat').


    Output Format:{jsonschema}


	Extraction Requirements:

    Parse and extract the three fields: Name, Job Title, and Address.
    Handle minor OCR inconsistencies, such as extra spaces or missing punctuation.
    Ensure correct parsing even if the house number is missing in the address.
	If more persons can be found in the sentence, fill the JSON schema for all of them.

	Additional Considerations:
	- Use separators like commas, line breaks, and key phrases to distinguish elements.
    - Extract as much valid data as possible, even if the input text is incomplete or ambiguous.
	- Correct common OCR mistakes.
    """
    
    system_prompt = PromptTemplate(system_template)

    evaluated_system_prompt = system_prompt.format(jsonschema=jsonschema)

    return evaluated_system_prompt


def Human_Message(record):

    template = """jsonschema,
    Record: {record}

    Please extract the relavent information from the given record.
    """
    prompt = PromptTemplate(template)
    
    evaluated_human_prompt = prompt.format(
                        record = record
    )

    return evaluated_human_prompt


def ask_llama(system, user):
	"""
	Sends a system and user message to a language model and returns the model's response.

	Args:
		system (str): The system message providing context or instructions for the model.
		user (str): The user message containing the query or input for the model.

	Returns:
		str: The response generated by the language model based on the provided system and user messages.
	"""
	messages = [{"role": "system", "content": system},
				{"role":"user","content":user}]


	completion = client.chat.completions.create(
		model=MODEL, 
		messages=messages
	)

	return completion.choices[0].message.content
    

schema = """
    Respond **ONLY** in valid JSON format, according to the following JSON schema:
    {
		"name": "",
		"jobTitle": "",
		"address": ""
	},
        "required": ["name", "jobTitle", "address"],
        "additionalProperties": false
    }

    
    Do NOT include the schema in your reply. Do NOT include any additional text outside of the JSON object.
    """


def load_json(path_to_json):
	"""
	Opens a JSON file and returns its content as a dictionary.

	Args:
		path_to_json (str): The path to the JSON file.

	Returns:
		dict: Parsed JSON data.
	"""
	try:
		with open(path_to_json, 'r') as f:
			data = json.load(f)
		return data
	except (FileNotFoundError, json.JSONDecodeError) as e:
		print(f"Error loading JSON file: {e}")
		return None


def get_text(data, first_page, last_page):
	"""
	Extracts text content from specified pages in the JSON data.

	Args:
		data (dict): JSON data containing the content.
		first_page (int): Starting page number (inclusive).
		last_page (int): Ending page number (inclusive).

	Returns:
		list: Text from the specified pages.
    """
	first_page_index = first_page -1
	last_page_index = last_page
	text_list = []

	for page in data['content'][first_page_index:last_page_index]:
		text = page['text'].replace('\n\n', '\n')
		text = text.replace('-\n', '')
		text = text.replace('\n', '')
		text_list.append(text)
		text = text.replace('{', '(')

	return text_list


def strip_text(text):
	"""
	Removes special characters, keeping only alphanumeric characters, spaces, commas, periods, and newlines.

	Args:
		text (str): The input text.

	Returns:
		str: Cleaned text.
	"""
	regex = re.compile(r"[^a-zA-Z0-9\s,.\n'\-\(\)\{\}]")
	return regex.sub('', text)


def split_by_housenumbers(text):
	"""
	Splits the input string based on housenumbers. A housenumber consists of 1-3 digits,
	optionally followed by a single letter, and ending with a punctuation mark.

	Args:
		text (str): The input string to split.

	Returns:
		list: A list of strings split by the housenumbers.
	"""
	pattern = r'(?<!\d)(\d{1,3}[A-Za-z]?[.,;!?\n])'
	return re.split(pattern, text)


def split_text_with_housenumbers_included(text):
	"""
	Splits the input string based on housenumbers. Each housenumber is included 
	in the line preceding it in the resulting list.

	A housenumber consists of 1-3 digits, optionally followed by a single letter, 
	and ending with a punctuation mark or newline. It cannot be preceded by other digits.

	Args:
		text (str): The input string to split.

	Returns:
		list: A list of strings where each housenumber is part of the preceding segment.
	"""
	pattern = r'(?<!\d)(\d{1,3}(?:[.,]\d{1,3})?[A-Za-z]?[.,;!?\n])'
	matches = re.finditer(pattern, text)

	# Keep track of the splits
	result = []
	last_end = 0

	for match in matches:
		start, end = match.span()
		# Include the current segment along with the housenumber
		result.append(text[last_end:end])
		last_end = end  # Update the position for the next split

	# Add the remaining text after the last match
	if last_end < len(text):
		result.append(text[last_end:])

	return result


def remove_phone_numbers(text):
	"""
	Removes phone numbers from the string. Phone numbers are formatted like 
	'tel. 31033' (e.g., 'tel. ' followed by a number).

	Args:
		text (str): The input string from which to remove phone numbers.

	Returns:
		str: The text with phone numbers removed.
	"""
    # Regex pattern to match phone numbers like 'tel. 31033'
	pattern = r'\b(?:[Tt]el|[Tt]elef|[Tt]elefoon)\.\s*\d+\b'
    
    # Remove all occurrences of the pattern
	return re.sub(pattern, '', text)


def add_spaces(sentence):
    """
    Adds spaces after periods if missing.

    Args:
        sentence (str): The input sentence.

    Returns:
        str: Formatted sentence with proper spacing.
    """
    sentence = re.sub(r'(?<=[.])(?=[^\s])', r' ', sentence)
    sentence = re.sub(r'\s+', ' ', sentence)
    
    return sentence


def dot_initials(string):
	"""
    Converts a string with capitalized words into a format where each word is followed by a dot.
    This function adds spaces between words and places dots after each initial capital letter.

    Args:
        string (str): The input string that may contain one or more capitalized words.

    Returns:
        str: The input string transformed with added spaces between words and dots after each initial letter.

    Example:
        input_string = "ThisIsAString"
        result = dot_initials(input_string)
        print(result)  # Output: "This. Is. A. String."
    """
	return re.sub(r'(?<=[A-Z])(?!\.)\b', '.', add_spaces(string))


def fix_initials_dot(line):
	"""
    Fixes initials by adding a period after the first capital letter.

    This function searches for pairs of an uppercase letter followed by a lowercase letter 
    (e.g., "A" followed by "b") in a string and adds a period after the uppercase letter, 
    effectively converting them into initials (e.g., "A." for "Ab").

    Args:
        line (str): The input string, which may contain initials or names.

    Returns:
        str: The string with corrected initials, where a period is added after the first capital letter.
    """
	pattern = r'\b([A-Z])([a-z])\b'
	return re.sub(pattern, r'\1.', line)


def fix_ocr_mistakes(text):
	"""
	Fixes OCR mistakes where the letter 'J' is mistaken for ')' or '}'.
	The function assumes the mistakes are in between '()' parentheses.
	"""
	return re.sub(r'\(([^)]*)\)', lambda x: f'({x.group(1).replace(")", "J.").replace("}", "J.")})', text)


def replace_digits_parentheses(text):
	"""
    Replaces occurrences of specific digits inside parentheses with the letter 'J'.
    Specifically, it replaces the digit '1' with 'J.', and '3' or '4' with 'J', within parentheses.

    Args:
        text (str): The input string containing text with parentheses and digits.

    Returns:
        str: The updated text where the specified digits inside parentheses are replaced with 'J'.

    Example:
        input_text = "This is a test (H. 1) and another (value 3)."
        result = replace_digits_parentheses(input_text)
        print(result)  # Output: "This is a test (H. J.) and another (value J)."
    """
    # Replace (1) with J, handling cases like (H. 1)
	updated_text = re.sub(r'\(.*[134].*\)', lambda match: match.group(0).replace('1', 'J.').replace('3', 'J').replace('4', 'J'), text)
	return updated_text


def make_page_json(year, page_number, person_list):
	"""
    Creates a dictionary (representing a JSON object) for a page containing information about a specific year,
    page number, and a list of people.

    Args:
        year (int): The year associated with the page.
        page_number (int): The page number within the document or register.
        person_list (list): A list of people (could be represented as dictionaries or any other structure) 
                            associated with the page.

    Returns:
        dict: A dictionary representing the page, containing the year, page number, and the list of people.

    Example:
        year = 2024
        page_number = 5
        person_list = [{"name": "John Doe", "age": 30}, {"name": "Jane Smith", "age": 28}]
        result = make_page_json(year, page_number, person_list)
        print(result)
        # Output: {'year': 2024, 'page': 5, 'register': [{'name': 'John Doe', 'age': 30}, {'name': 'Jane Smith', 'age': 28}]}
    """
	page_object = {
			"year": year,
			"page": page_number,
			"register": person_list
	}
	return page_object


BASEURL = 'http://localhost:8000/v1/'
APIKEY = 'EMPTY'
MODEL = "meta-llama/Llama-3.1-8B-Instruct"

client = OpenAI(base_url=BASEURL,api_key=APIKEY)

year = "1926"
path_to_json = f"book_text/{year}.json"

# Load the JSON data from the specified path
data = load_json(path_to_json)
first_page, last_page = 121, 131

logging.basicConfig(level=logging.ERROR)

# Proceed if data is loaded successfully
if data:
	# Get text from specified pages
	text_list = get_text(data, first_page, last_page)

	# Process each page
	for index, page in tqdm(enumerate(text_list), total=len(text_list), desc='Processing Pages', unit='page', ncols=100):
		person_list = []
		page_number = index + first_page
		page = strip_text(page)
		page_list = split_text_with_housenumbers_included(page)
		with_parentheses = [line for line in page_list if '(' in line or ')' in line]

		for i in with_parentheses:
			i = i.strip()
			line = remove_phone_numbers(i)
			if len(line) > 15 and len(line) < 150:
				line_dotted = dot_initials(line)
				line_starts_with_letter = re.sub(r'^[^a-zA-Z]+', '', line_dotted)
				line_fixed_parentheses = replace_digits_parentheses(line_starts_with_letter)

				user = Human_Message(line_fixed_parentheses)
				system = System_Message(jsonschema=schema)
				output = ask_llama(system, user)

				json_objects = re.findall(r'\{.*?\}', output, re.DOTALL)
				for obj in json_objects:
					try:
						person_list.append(json.loads(obj))
					except json.JSONDecodeError as e:
						pass

		page_object = json.dumps(make_page_json(year, page_number, person_list), indent=4)
		output_directory = f"register/{year}"
		os.makedirs(output_directory, exist_ok=True)
		json_filename = f'{output_directory}/{year}_{page_number}.json'

		with open(json_filename, 'w+') as output_file:
			output_file.write(page_object)

		output_file.close()